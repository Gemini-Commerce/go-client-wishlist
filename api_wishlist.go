/*
Wishlist Service

API for managing wishlists

API version: v1
Contact: info@gemini-commerce.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package wishlist

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type WishlistAPI interface {

	/*
		WishlistAddItemToWishlist Method for WishlistAddItemToWishlist

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistAddItemToWishlistRequest
	*/
	WishlistAddItemToWishlist(ctx context.Context) ApiWishlistAddItemToWishlistRequest

	// WishlistAddItemToWishlistExecute executes the request
	//  @return WishlistWishlistItemResponse
	WishlistAddItemToWishlistExecute(r ApiWishlistAddItemToWishlistRequest) (*WishlistWishlistItemResponse, *http.Response, error)

	/*
		WishlistAreItemsInWishlists Method for WishlistAreItemsInWishlists

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistAreItemsInWishlistsRequest
	*/
	WishlistAreItemsInWishlists(ctx context.Context) ApiWishlistAreItemsInWishlistsRequest

	// WishlistAreItemsInWishlistsExecute executes the request
	//  @return WishlistAreItemsInWishlistsResponse
	WishlistAreItemsInWishlistsExecute(r ApiWishlistAreItemsInWishlistsRequest) (*WishlistAreItemsInWishlistsResponse, *http.Response, error)

	/*
		WishlistBulkCreateSharing Sharing endpoints

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistBulkCreateSharingRequest
	*/
	WishlistBulkCreateSharing(ctx context.Context) ApiWishlistBulkCreateSharingRequest

	// WishlistBulkCreateSharingExecute executes the request
	//  @return WishlistBulkCreateSharingResponse
	WishlistBulkCreateSharingExecute(r ApiWishlistBulkCreateSharingRequest) (*WishlistBulkCreateSharingResponse, *http.Response, error)

	/*
		WishlistBulkRemoveItemsFromWishlists BulkRemoveItemsFromWishlists removes items from wishlists.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistBulkRemoveItemsFromWishlistsRequest
	*/
	WishlistBulkRemoveItemsFromWishlists(ctx context.Context) ApiWishlistBulkRemoveItemsFromWishlistsRequest

	// WishlistBulkRemoveItemsFromWishlistsExecute executes the request
	//  @return map[string]interface{}
	WishlistBulkRemoveItemsFromWishlistsExecute(r ApiWishlistBulkRemoveItemsFromWishlistsRequest) (map[string]interface{}, *http.Response, error)

	/*
		WishlistBulkRevokeSharing Method for WishlistBulkRevokeSharing

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistBulkRevokeSharingRequest
	*/
	WishlistBulkRevokeSharing(ctx context.Context) ApiWishlistBulkRevokeSharingRequest

	// WishlistBulkRevokeSharingExecute executes the request
	//  @return map[string]interface{}
	WishlistBulkRevokeSharingExecute(r ApiWishlistBulkRevokeSharingRequest) (map[string]interface{}, *http.Response, error)

	/*
		WishlistCreateWishlist Method for WishlistCreateWishlist

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistCreateWishlistRequest
	*/
	WishlistCreateWishlist(ctx context.Context) ApiWishlistCreateWishlistRequest

	// WishlistCreateWishlistExecute executes the request
	//  @return WishlistWishlistResponse
	WishlistCreateWishlistExecute(r ApiWishlistCreateWishlistRequest) (*WishlistWishlistResponse, *http.Response, error)

	/*
		WishlistDeleteWishlist Method for WishlistDeleteWishlist

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistDeleteWishlistRequest
	*/
	WishlistDeleteWishlist(ctx context.Context) ApiWishlistDeleteWishlistRequest

	// WishlistDeleteWishlistExecute executes the request
	//  @return map[string]interface{}
	WishlistDeleteWishlistExecute(r ApiWishlistDeleteWishlistRequest) (map[string]interface{}, *http.Response, error)

	/*
		WishlistGetItemFromWishlist Method for WishlistGetItemFromWishlist

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistGetItemFromWishlistRequest
	*/
	WishlistGetItemFromWishlist(ctx context.Context) ApiWishlistGetItemFromWishlistRequest

	// WishlistGetItemFromWishlistExecute executes the request
	//  @return WishlistWishlistItemResponse
	WishlistGetItemFromWishlistExecute(r ApiWishlistGetItemFromWishlistRequest) (*WishlistWishlistItemResponse, *http.Response, error)

	/*
		WishlistGetWishlistById Method for WishlistGetWishlistById

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistGetWishlistByIdRequest
	*/
	WishlistGetWishlistById(ctx context.Context) ApiWishlistGetWishlistByIdRequest

	// WishlistGetWishlistByIdExecute executes the request
	//  @return WishlistWishlistResponse
	WishlistGetWishlistByIdExecute(r ApiWishlistGetWishlistByIdRequest) (*WishlistWishlistResponse, *http.Response, error)

	/*
		WishlistGetWishlistBySharedCode Method for WishlistGetWishlistBySharedCode

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistGetWishlistBySharedCodeRequest
	*/
	WishlistGetWishlistBySharedCode(ctx context.Context) ApiWishlistGetWishlistBySharedCodeRequest

	// WishlistGetWishlistBySharedCodeExecute executes the request
	//  @return WishlistWishlistResponse
	WishlistGetWishlistBySharedCodeExecute(r ApiWishlistGetWishlistBySharedCodeRequest) (*WishlistWishlistResponse, *http.Response, error)

	/*
		WishlistListWishlistItems Method for WishlistListWishlistItems

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistListWishlistItemsRequest
	*/
	WishlistListWishlistItems(ctx context.Context) ApiWishlistListWishlistItemsRequest

	// WishlistListWishlistItemsExecute executes the request
	//  @return WishlistListWishlistItemsResponse
	WishlistListWishlistItemsExecute(r ApiWishlistListWishlistItemsRequest) (*WishlistListWishlistItemsResponse, *http.Response, error)

	/*
		WishlistListWishlists Method for WishlistListWishlists

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistListWishlistsRequest
	*/
	WishlistListWishlists(ctx context.Context) ApiWishlistListWishlistsRequest

	// WishlistListWishlistsExecute executes the request
	//  @return WishlistListWishlistsResponse
	WishlistListWishlistsExecute(r ApiWishlistListWishlistsRequest) (*WishlistListWishlistsResponse, *http.Response, error)

	/*
		WishlistMergeWishlists Method for WishlistMergeWishlists

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistMergeWishlistsRequest
	*/
	WishlistMergeWishlists(ctx context.Context) ApiWishlistMergeWishlistsRequest

	// WishlistMergeWishlistsExecute executes the request
	//  @return WishlistWishlistResponse
	WishlistMergeWishlistsExecute(r ApiWishlistMergeWishlistsRequest) (*WishlistWishlistResponse, *http.Response, error)

	/*
		WishlistRemoveItemFromWishlist Method for WishlistRemoveItemFromWishlist

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistRemoveItemFromWishlistRequest
	*/
	WishlistRemoveItemFromWishlist(ctx context.Context) ApiWishlistRemoveItemFromWishlistRequest

	// WishlistRemoveItemFromWishlistExecute executes the request
	//  @return map[string]interface{}
	WishlistRemoveItemFromWishlistExecute(r ApiWishlistRemoveItemFromWishlistRequest) (map[string]interface{}, *http.Response, error)

	/*
		WishlistUpdateItemInWishlist Method for WishlistUpdateItemInWishlist

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistUpdateItemInWishlistRequest
	*/
	WishlistUpdateItemInWishlist(ctx context.Context) ApiWishlistUpdateItemInWishlistRequest

	// WishlistUpdateItemInWishlistExecute executes the request
	//  @return WishlistWishlistItemResponse
	WishlistUpdateItemInWishlistExecute(r ApiWishlistUpdateItemInWishlistRequest) (*WishlistWishlistItemResponse, *http.Response, error)

	/*
		WishlistUpdateWishlist Method for WishlistUpdateWishlist

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiWishlistUpdateWishlistRequest
	*/
	WishlistUpdateWishlist(ctx context.Context) ApiWishlistUpdateWishlistRequest

	// WishlistUpdateWishlistExecute executes the request
	//  @return WishlistWishlistResponse
	WishlistUpdateWishlistExecute(r ApiWishlistUpdateWishlistRequest) (*WishlistWishlistResponse, *http.Response, error)
}

// WishlistAPIService WishlistAPI service
type WishlistAPIService service

type ApiWishlistAddItemToWishlistRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistAddItemToWishlistRequest
}

func (r ApiWishlistAddItemToWishlistRequest) Body(body WishlistAddItemToWishlistRequest) ApiWishlistAddItemToWishlistRequest {
	r.body = &body
	return r
}

func (r ApiWishlistAddItemToWishlistRequest) Execute() (*WishlistWishlistItemResponse, *http.Response, error) {
	return r.ApiService.WishlistAddItemToWishlistExecute(r)
}

/*
WishlistAddItemToWishlist Method for WishlistAddItemToWishlist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistAddItemToWishlistRequest
*/
func (a *WishlistAPIService) WishlistAddItemToWishlist(ctx context.Context) ApiWishlistAddItemToWishlistRequest {
	return ApiWishlistAddItemToWishlistRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistItemResponse
func (a *WishlistAPIService) WishlistAddItemToWishlistExecute(r ApiWishlistAddItemToWishlistRequest) (*WishlistWishlistItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistAddItemToWishlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/AddItemToWishlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistAreItemsInWishlistsRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistAreItemsInWishlistsRequest
}

func (r ApiWishlistAreItemsInWishlistsRequest) Body(body WishlistAreItemsInWishlistsRequest) ApiWishlistAreItemsInWishlistsRequest {
	r.body = &body
	return r
}

func (r ApiWishlistAreItemsInWishlistsRequest) Execute() (*WishlistAreItemsInWishlistsResponse, *http.Response, error) {
	return r.ApiService.WishlistAreItemsInWishlistsExecute(r)
}

/*
WishlistAreItemsInWishlists Method for WishlistAreItemsInWishlists

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistAreItemsInWishlistsRequest
*/
func (a *WishlistAPIService) WishlistAreItemsInWishlists(ctx context.Context) ApiWishlistAreItemsInWishlistsRequest {
	return ApiWishlistAreItemsInWishlistsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistAreItemsInWishlistsResponse
func (a *WishlistAPIService) WishlistAreItemsInWishlistsExecute(r ApiWishlistAreItemsInWishlistsRequest) (*WishlistAreItemsInWishlistsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistAreItemsInWishlistsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistAreItemsInWishlists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/AreItemsInWishlists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistBulkCreateSharingRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistBulkCreateSharingRequest
}

func (r ApiWishlistBulkCreateSharingRequest) Body(body WishlistBulkCreateSharingRequest) ApiWishlistBulkCreateSharingRequest {
	r.body = &body
	return r
}

func (r ApiWishlistBulkCreateSharingRequest) Execute() (*WishlistBulkCreateSharingResponse, *http.Response, error) {
	return r.ApiService.WishlistBulkCreateSharingExecute(r)
}

/*
WishlistBulkCreateSharing Sharing endpoints

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistBulkCreateSharingRequest
*/
func (a *WishlistAPIService) WishlistBulkCreateSharing(ctx context.Context) ApiWishlistBulkCreateSharingRequest {
	return ApiWishlistBulkCreateSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistBulkCreateSharingResponse
func (a *WishlistAPIService) WishlistBulkCreateSharingExecute(r ApiWishlistBulkCreateSharingRequest) (*WishlistBulkCreateSharingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistBulkCreateSharingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistBulkCreateSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/BulkCreateSharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistBulkRemoveItemsFromWishlistsRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistBulkRemoveItemsFromWishlistsRequest
}

func (r ApiWishlistBulkRemoveItemsFromWishlistsRequest) Body(body WishlistBulkRemoveItemsFromWishlistsRequest) ApiWishlistBulkRemoveItemsFromWishlistsRequest {
	r.body = &body
	return r
}

func (r ApiWishlistBulkRemoveItemsFromWishlistsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.WishlistBulkRemoveItemsFromWishlistsExecute(r)
}

/*
WishlistBulkRemoveItemsFromWishlists BulkRemoveItemsFromWishlists removes items from wishlists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistBulkRemoveItemsFromWishlistsRequest
*/
func (a *WishlistAPIService) WishlistBulkRemoveItemsFromWishlists(ctx context.Context) ApiWishlistBulkRemoveItemsFromWishlistsRequest {
	return ApiWishlistBulkRemoveItemsFromWishlistsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *WishlistAPIService) WishlistBulkRemoveItemsFromWishlistsExecute(r ApiWishlistBulkRemoveItemsFromWishlistsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistBulkRemoveItemsFromWishlists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/BulkRemoveItemsFromWishlists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistBulkRevokeSharingRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistBulkRevokeSharingRequest
}

func (r ApiWishlistBulkRevokeSharingRequest) Body(body WishlistBulkRevokeSharingRequest) ApiWishlistBulkRevokeSharingRequest {
	r.body = &body
	return r
}

func (r ApiWishlistBulkRevokeSharingRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.WishlistBulkRevokeSharingExecute(r)
}

/*
WishlistBulkRevokeSharing Method for WishlistBulkRevokeSharing

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistBulkRevokeSharingRequest
*/
func (a *WishlistAPIService) WishlistBulkRevokeSharing(ctx context.Context) ApiWishlistBulkRevokeSharingRequest {
	return ApiWishlistBulkRevokeSharingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *WishlistAPIService) WishlistBulkRevokeSharingExecute(r ApiWishlistBulkRevokeSharingRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistBulkRevokeSharing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/BulkRevokeSharing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistCreateWishlistRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistCreateWishlistRequest
}

func (r ApiWishlistCreateWishlistRequest) Body(body WishlistCreateWishlistRequest) ApiWishlistCreateWishlistRequest {
	r.body = &body
	return r
}

func (r ApiWishlistCreateWishlistRequest) Execute() (*WishlistWishlistResponse, *http.Response, error) {
	return r.ApiService.WishlistCreateWishlistExecute(r)
}

/*
WishlistCreateWishlist Method for WishlistCreateWishlist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistCreateWishlistRequest
*/
func (a *WishlistAPIService) WishlistCreateWishlist(ctx context.Context) ApiWishlistCreateWishlistRequest {
	return ApiWishlistCreateWishlistRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistResponse
func (a *WishlistAPIService) WishlistCreateWishlistExecute(r ApiWishlistCreateWishlistRequest) (*WishlistWishlistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistCreateWishlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/CreateWishlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistDeleteWishlistRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistDeleteWishlistRequest
}

func (r ApiWishlistDeleteWishlistRequest) Body(body WishlistDeleteWishlistRequest) ApiWishlistDeleteWishlistRequest {
	r.body = &body
	return r
}

func (r ApiWishlistDeleteWishlistRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.WishlistDeleteWishlistExecute(r)
}

/*
WishlistDeleteWishlist Method for WishlistDeleteWishlist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistDeleteWishlistRequest
*/
func (a *WishlistAPIService) WishlistDeleteWishlist(ctx context.Context) ApiWishlistDeleteWishlistRequest {
	return ApiWishlistDeleteWishlistRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *WishlistAPIService) WishlistDeleteWishlistExecute(r ApiWishlistDeleteWishlistRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistDeleteWishlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/DeleteWishlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistGetItemFromWishlistRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistGetItemFromWishlistRequest
}

func (r ApiWishlistGetItemFromWishlistRequest) Body(body WishlistGetItemFromWishlistRequest) ApiWishlistGetItemFromWishlistRequest {
	r.body = &body
	return r
}

func (r ApiWishlistGetItemFromWishlistRequest) Execute() (*WishlistWishlistItemResponse, *http.Response, error) {
	return r.ApiService.WishlistGetItemFromWishlistExecute(r)
}

/*
WishlistGetItemFromWishlist Method for WishlistGetItemFromWishlist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistGetItemFromWishlistRequest
*/
func (a *WishlistAPIService) WishlistGetItemFromWishlist(ctx context.Context) ApiWishlistGetItemFromWishlistRequest {
	return ApiWishlistGetItemFromWishlistRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistItemResponse
func (a *WishlistAPIService) WishlistGetItemFromWishlistExecute(r ApiWishlistGetItemFromWishlistRequest) (*WishlistWishlistItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistGetItemFromWishlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/GetItemFromWishlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistGetWishlistByIdRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistGetWishlistByIdRequest
}

func (r ApiWishlistGetWishlistByIdRequest) Body(body WishlistGetWishlistByIdRequest) ApiWishlistGetWishlistByIdRequest {
	r.body = &body
	return r
}

func (r ApiWishlistGetWishlistByIdRequest) Execute() (*WishlistWishlistResponse, *http.Response, error) {
	return r.ApiService.WishlistGetWishlistByIdExecute(r)
}

/*
WishlistGetWishlistById Method for WishlistGetWishlistById

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistGetWishlistByIdRequest
*/
func (a *WishlistAPIService) WishlistGetWishlistById(ctx context.Context) ApiWishlistGetWishlistByIdRequest {
	return ApiWishlistGetWishlistByIdRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistResponse
func (a *WishlistAPIService) WishlistGetWishlistByIdExecute(r ApiWishlistGetWishlistByIdRequest) (*WishlistWishlistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistGetWishlistById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/GetWishlistById"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistGetWishlistBySharedCodeRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistGetWishlistBySharedCodeRequest
}

func (r ApiWishlistGetWishlistBySharedCodeRequest) Body(body WishlistGetWishlistBySharedCodeRequest) ApiWishlistGetWishlistBySharedCodeRequest {
	r.body = &body
	return r
}

func (r ApiWishlistGetWishlistBySharedCodeRequest) Execute() (*WishlistWishlistResponse, *http.Response, error) {
	return r.ApiService.WishlistGetWishlistBySharedCodeExecute(r)
}

/*
WishlistGetWishlistBySharedCode Method for WishlistGetWishlistBySharedCode

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistGetWishlistBySharedCodeRequest
*/
func (a *WishlistAPIService) WishlistGetWishlistBySharedCode(ctx context.Context) ApiWishlistGetWishlistBySharedCodeRequest {
	return ApiWishlistGetWishlistBySharedCodeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistResponse
func (a *WishlistAPIService) WishlistGetWishlistBySharedCodeExecute(r ApiWishlistGetWishlistBySharedCodeRequest) (*WishlistWishlistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistGetWishlistBySharedCode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/GetWishlistBySharedCode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistListWishlistItemsRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistListWishlistItemsRequest
}

func (r ApiWishlistListWishlistItemsRequest) Body(body WishlistListWishlistItemsRequest) ApiWishlistListWishlistItemsRequest {
	r.body = &body
	return r
}

func (r ApiWishlistListWishlistItemsRequest) Execute() (*WishlistListWishlistItemsResponse, *http.Response, error) {
	return r.ApiService.WishlistListWishlistItemsExecute(r)
}

/*
WishlistListWishlistItems Method for WishlistListWishlistItems

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistListWishlistItemsRequest
*/
func (a *WishlistAPIService) WishlistListWishlistItems(ctx context.Context) ApiWishlistListWishlistItemsRequest {
	return ApiWishlistListWishlistItemsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistListWishlistItemsResponse
func (a *WishlistAPIService) WishlistListWishlistItemsExecute(r ApiWishlistListWishlistItemsRequest) (*WishlistListWishlistItemsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistListWishlistItemsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistListWishlistItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/ListWishlistItems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistListWishlistsRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistListWishlistsRequest
}

func (r ApiWishlistListWishlistsRequest) Body(body WishlistListWishlistsRequest) ApiWishlistListWishlistsRequest {
	r.body = &body
	return r
}

func (r ApiWishlistListWishlistsRequest) Execute() (*WishlistListWishlistsResponse, *http.Response, error) {
	return r.ApiService.WishlistListWishlistsExecute(r)
}

/*
WishlistListWishlists Method for WishlistListWishlists

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistListWishlistsRequest
*/
func (a *WishlistAPIService) WishlistListWishlists(ctx context.Context) ApiWishlistListWishlistsRequest {
	return ApiWishlistListWishlistsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistListWishlistsResponse
func (a *WishlistAPIService) WishlistListWishlistsExecute(r ApiWishlistListWishlistsRequest) (*WishlistListWishlistsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistListWishlistsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistListWishlists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/ListWishlists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistMergeWishlistsRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistMergeWishlistsRequest
}

func (r ApiWishlistMergeWishlistsRequest) Body(body WishlistMergeWishlistsRequest) ApiWishlistMergeWishlistsRequest {
	r.body = &body
	return r
}

func (r ApiWishlistMergeWishlistsRequest) Execute() (*WishlistWishlistResponse, *http.Response, error) {
	return r.ApiService.WishlistMergeWishlistsExecute(r)
}

/*
WishlistMergeWishlists Method for WishlistMergeWishlists

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistMergeWishlistsRequest
*/
func (a *WishlistAPIService) WishlistMergeWishlists(ctx context.Context) ApiWishlistMergeWishlistsRequest {
	return ApiWishlistMergeWishlistsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistResponse
func (a *WishlistAPIService) WishlistMergeWishlistsExecute(r ApiWishlistMergeWishlistsRequest) (*WishlistWishlistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistMergeWishlists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/MergeWishlists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistRemoveItemFromWishlistRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistRemoveItemFromWishlistRequest
}

func (r ApiWishlistRemoveItemFromWishlistRequest) Body(body WishlistRemoveItemFromWishlistRequest) ApiWishlistRemoveItemFromWishlistRequest {
	r.body = &body
	return r
}

func (r ApiWishlistRemoveItemFromWishlistRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.WishlistRemoveItemFromWishlistExecute(r)
}

/*
WishlistRemoveItemFromWishlist Method for WishlistRemoveItemFromWishlist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistRemoveItemFromWishlistRequest
*/
func (a *WishlistAPIService) WishlistRemoveItemFromWishlist(ctx context.Context) ApiWishlistRemoveItemFromWishlistRequest {
	return ApiWishlistRemoveItemFromWishlistRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *WishlistAPIService) WishlistRemoveItemFromWishlistExecute(r ApiWishlistRemoveItemFromWishlistRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistRemoveItemFromWishlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/RemoveItemFromWishlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistUpdateItemInWishlistRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistUpdateItemInWishlistRequest
}

func (r ApiWishlistUpdateItemInWishlistRequest) Body(body WishlistUpdateItemInWishlistRequest) ApiWishlistUpdateItemInWishlistRequest {
	r.body = &body
	return r
}

func (r ApiWishlistUpdateItemInWishlistRequest) Execute() (*WishlistWishlistItemResponse, *http.Response, error) {
	return r.ApiService.WishlistUpdateItemInWishlistExecute(r)
}

/*
WishlistUpdateItemInWishlist Method for WishlistUpdateItemInWishlist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistUpdateItemInWishlistRequest
*/
func (a *WishlistAPIService) WishlistUpdateItemInWishlist(ctx context.Context) ApiWishlistUpdateItemInWishlistRequest {
	return ApiWishlistUpdateItemInWishlistRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistItemResponse
func (a *WishlistAPIService) WishlistUpdateItemInWishlistExecute(r ApiWishlistUpdateItemInWishlistRequest) (*WishlistWishlistItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistUpdateItemInWishlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/UpdateItemInWishlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWishlistUpdateWishlistRequest struct {
	ctx        context.Context
	ApiService WishlistAPI
	body       *WishlistUpdateWishlistRequest
}

func (r ApiWishlistUpdateWishlistRequest) Body(body WishlistUpdateWishlistRequest) ApiWishlistUpdateWishlistRequest {
	r.body = &body
	return r
}

func (r ApiWishlistUpdateWishlistRequest) Execute() (*WishlistWishlistResponse, *http.Response, error) {
	return r.ApiService.WishlistUpdateWishlistExecute(r)
}

/*
WishlistUpdateWishlist Method for WishlistUpdateWishlist

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiWishlistUpdateWishlistRequest
*/
func (a *WishlistAPIService) WishlistUpdateWishlist(ctx context.Context) ApiWishlistUpdateWishlistRequest {
	return ApiWishlistUpdateWishlistRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WishlistWishlistResponse
func (a *WishlistAPIService) WishlistUpdateWishlistExecute(r ApiWishlistUpdateWishlistRequest) (*WishlistWishlistResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WishlistWishlistResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WishlistAPIService.WishlistUpdateWishlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wishlist.Wishlist/UpdateWishlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Authorization"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v RpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
